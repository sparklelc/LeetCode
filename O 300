Mid
300 Longest Increasing Subsequence
Given an unsorted array of integers, find the length of longest increasing subsequence.
For example,
   Given [10, 9, 2, 5, 3, 7, 101, 18],
   The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4. 
Note that there may be more than one LIS combination, it is only necessary for you to return the length.
   Your algorithm should run in O(n2) complexity.
   Follow up: Could you improve it to O(n log n) time complexity?
找最长的递增序列的长度

我的思路：
最容易想到的动态规划O(n*n)
但我用min-heap做，实际上用堆做的复杂度为O(n*n*lgn)

别人思路：
二分查找，复杂度O(n*lgn)
For example, say we have nums = [4,5,6,3], then all the available increasing subsequences are:
  len = 1 :   [4], [5], [6], [3]   => tails[0] = 3
  len = 2 :   [4, 5], [5, 6]       => tails[1] = 5
  len = 3 :   [4, 5, 6]            => tails[2] = 6
用一个新的数组tail[i]来表示递增长度为i的所有序列中最后一位最小是多少。

//我参照别人的代码
public class Solution {
    public int lengthOfLIS(int[] nums) {
        int[] arr = new int[nums.length];
        int size = 0;
        for (int num: nums) {
            int i=0;
            int j=size;                      //二分查找，在i和j都在范围内的情况下, 更新i是i=mid+1
            while (i != j) {
                int mid = (i+j)/2;
                if (arr[mid]<num)
                    i = mid+1;
                else
                    j = mid;
            }
            arr[j] = num;
            if (j == size) size++;
        }
        return size;
    }
}
