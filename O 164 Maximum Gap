Hard:
Given an unsorted array, find the maximum difference between the successive elements in its sorted form.
Try to solve it in linear time/space.
Return 0 if the array contains less than 2 elements.
You may assume all elements in the array are non-negative integers and fit in the 32-bit signed integer range.
给无序的数组,找出连续的最大间隔. 要求O(n)


思路:
还是要排序来做，要求O(n)，可以用"桶排序"，关键是要用多少个桶
1. 遍历一次，找处最大和最小的元素maxInt, minInt
2. 最大间隔不会小于seg = (maxInt - minInt)/(n-1)
3. 分成n个段，(如[1，2]，第一个段[1，2), 第二个段[2,X).)
4. 记录每个段的最大和最小元素
5. 从左向右, 找左边段的最大值和右边段的最小值的最大间隔.


//参照别人思路我的代码
public class Solution {
    public int maximumGap(int[] nums) {
        if (nums == null || nums.length < 2)
            return 0;
        int[] min = new int[nums.length+1];
        int[] max = new int[nums.length+1];
        int maxInt = 0;
        int minInt = Integer.MAX_VALUE;
        for (int num: nums) {
            if (num > maxInt)
                maxInt = num;
            if (num < minInt)
                minInt = num;
        }
        
        double slot = (maxInt - minInt) / (nums.length-1.0);
        if (slot == 0)
            return 0;
        for (int num: nums) {
            int index = (int) ((num - minInt) / (slot));
            if (min[index] == 0 || min[index] > num) {
                min[index] = num;
            }
            if (max[index] == 0 || max[index] < num) {
                max[index] = num;
            }
        }
        
        int last = max[0];
        int result = (maxInt-minInt)/(nums.length-1);
        for (int i=0; i<=nums.length; i++) {
            if (min[i] != 0 && min[i] != last) {
                result = Math.max(result, min[i] - last);
                last = max[i];
            }
        }
        return result;
    }
}
