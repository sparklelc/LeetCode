Hard:
282 Expression Add Operators
    Given a string that contains only digits 0-9 and a target value, return all possibilities to add binary operators 
  (not unary) +, -, or * between the digits so they evaluate to the target value.
Examples: 
  "123", 6 -> ["1+2+3", "1*2*3"] 
  "232", 8 -> ["2*3+2", "2+3*2"]
  "105", 5 -> ["1*0+5","10-5"]
  "00", 0 -> ["0+0", "0-0", "0*0"]
  "3456237490", 9191 -> []
  
我的思路：
找出所有string，找完后判断每个string的结果是否与target相同
beat 0.83% 慢

别人思路：
缓存前面的结果

//别人代码
public class Solution {
    List<String> res;
    public List<String> addOperators(String num, int target) {
        helper(num, target, "", 0, 0);
        return res;
    }
    
    private void helper(String num, int target, String tmp, long currRes, long prevNum){
        // 如果计算结果等于目标值，且所有数都用完了，则是有效结果
        if(currRes == target && num.length() == 0){
            String exp = new String(tmp);
            res.add(exp);
            return;
        }
        // 搜索所有可能的拆分情况
        for(int i = 1; i <= num.length(); i++){
            String currStr = num.substring(0, i);
            // 对于前导为0的数予以排除
            if(currStr.length() > 1 && currStr.charAt(0) == '0'){
                // 这里是return不是continue
                return;
            }
            // 得到当前截出的数
            long currNum = Long.parseLong(currStr);
            // 去掉当前的数，得到下一轮搜索用的字符串
            String next = num.substring(i);
            // 如果不是第一个字母时，可以加运算符，否则只加数字
            if(tmp.length() != 0){
                // 乘法
                helper(next, target, tmp+"*"+currNum, (currRes - prevNum) + prevNum * currNum, prevNum * currNum);
                // 加法
                helper(next, target, tmp+"+"+currNum, currRes + currNum, currNum);
                // 减法
                helper(next, target, tmp+"-"+currNum, currRes - currNum, -currNum); 
            } else {
                // 第一个数
                helper(next, target, currStr, currNum, currNum);
            }
        }
    }
}


************************************************************
Hard:
287 Find the Duplicate Number
Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), 
prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one.
Note:
You must not modify the array (assume the array is read only).
You must use only constant, O(1) extra space.
Your runtime complexity should be less than O(n2).
There is only one duplicate number in the array, but it could be repeated more than once.
找出重复的数(可以重复多次)

别人思路:
类似于链表找环交点，复杂度O(n).
由于index范围是0-(n-1)，而数字范围是1-n,所以从index=0开始找理论上只有有重复数字的时候才会形成环路，而重复数字就是环交点.


//参照别人思路我的代码
public class Solution {
    public int findDuplicate(int[] nums) {
        if (nums == null || nums.length < 2) return -1;
        int fast = nums[nums[0]];
        int slow = nums[0];
        while (fast != slow) {
            fast = nums[nums[fast]];
            slow = nums[slow];
        }
        fast = 0;
        while (fast != slow) {
            fast = nums[fast];
            slow = nums[slow];
        }
        return slow;
    }
}
