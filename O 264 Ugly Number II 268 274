Mid
264 Ugly Number II
Write a program to find the n-th ugly number.
Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. 
For example, 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 is the sequence of the first 10 ugly numbers.
Note that 1 is typically treated as an ugly number.
找出第i个丑数

别人思路：
某个丑数一定是另外一个丑数的2,3或5倍，用index2,index3,index5标志位置
每次取三个丑数的结果中的最小值

//参照别人我的代码
public class Solution {
    public int nthUglyNumber(int n) {
        int[] result = new int[n+1];
        result[1] = 1;
        int index2=1, index3=1, index5=1;
        
        int count = 1;
        while (count < n) {
            count++;
            result[count] = Math.min(result[index2]*2, Math.min(result[index3]*3, result[index5]*5));
            if (result[count] == result[index2]*2)
                index2++;
            if (result[count] == result[index3]*3)        //注意不能用else if，因为比如2*3 == 3*2，如果重复只取一次
                index3++;
            if (result[count] == result[index5]*5)
                index5++;
        }
        return result[n];
    }
}

********************************************************************
Easy
268 Missing Number
Given an array containing n distinct numbers taken from 0, 1, 2, ..., n, find the one that is missing from the array.
For example,
Given nums = [0, 1, 3] return 2.
找出丢失的元素，数组不一定是有序的。

我的思路：
求和，减法

别人思路：
用异或
public int missingNumber(int[] nums) {
    int res = nums.length;
    for(int i=0; i<nums.length; i++) {
        res ^= i;
        res ^= nums[i];
    }
    return res;
}

************************************************************************
Mid
274 H-Index
According to the definition of h-index on Wikipedia: "A scientist has index h if h of his/her N papers have at least h citations
each, and the other N − h papers have no more than h citations each."
For example, given citations = [3, 0, 6, 1, 5], which means the researcher has 5 papers in total and each of them had received 
3, 0, 6, 1, 5 citations respectively. Since the researcher has 3 papers with at least 3 citations each and the remaining two 
with no more than 3 citations each, his h-index is 3.
至少h篇论文被索引h次

我的思路:
排序,复杂度O(n*lgn)

别人思路：
用数组进行计数，所有大于citations.length的都记在count[citations.length]上面
复杂度O(n)

//参照别人我的代码
public class Solution {
    public int hIndex(int[] citations) {
        int[] count = new int[citations.length+1];       //用于计数的作用
        for (int i=0; i<citations.length; i++) {
            if (citations[i] >= citations.length)
                count[citations.length]++;               //大于citations.length的值全部计入count[citations.length]
            else
                count[citations[i]]++;
        }
        int total=0;
        for (int i=citations.length; i>=0; i--) {
            total += count[i];
            if (total >= i) return i;
        }
        return 0;
    }
}
