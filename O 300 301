Mid
300 Longest Increasing Subsequence
Given an unsorted array of integers, find the length of longest increasing subsequence.
For example,
   Given [10, 9, 2, 5, 3, 7, 101, 18],
   The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4. 
Note that there may be more than one LIS combination, it is only necessary for you to return the length.
   Your algorithm should run in O(n2) complexity.
   Follow up: Could you improve it to O(n log n) time complexity?
找最长的递增序列的长度

我的思路：
最容易想到的动态规划O(n*n)
但我用min-heap做，实际上用堆做的复杂度为O(n*n*lgn)

别人思路：
二分查找，复杂度O(n*lgn)
For example, say we have nums = [4,5,6,3], then all the available increasing subsequences are:
  len = 1 :   [4], [5], [6], [3]   => tails[0] = 3
  len = 2 :   [4, 5], [5, 6]       => tails[1] = 5
  len = 3 :   [4, 5, 6]            => tails[2] = 6
用一个新的数组tail[i]来表示递增长度为i的所有序列中最后一位最小是多少。

//我参照别人的代码
public class Solution {
    public int lengthOfLIS(int[] nums) {
        int[] arr = new int[nums.length];
        int size = 0;                        //限定二叉搜索范围
        for (int num: nums) {
            int i=0;
            int j=size;                      //二分查找，在i和j都在范围内的情况下, 更新i是i=mid+1
            while (i != j) {
                int mid = (i+j)/2;
                if (arr[mid]<num)
                    i = mid+1;
                else
                    j = mid;
            }
            arr[j] = num;
            if (j == size) size++;
        }
        return size;
    }
}


***************************************************************************
Hard
301 Remove Invalid Parentheses
Remove the minimum number of invalid parentheses in order to make the input string valid. Return all possible results.
Note: The input string may contain letters other than the parentheses ( and ).
Examples:
   "()())()" -> ["()()()", "(())()"]
   "(a)())()" -> ["(a)()()", "(a())()"]
   ")(" -> [""]
   
别人思路:
第一遍去掉不满足的')'，第二遍去掉不满足的'('
注意避免得到相同的结果，比如())删第2个或者第三个')'得到的结果其实是相同的。
本题的判断方法比较好，可以深入思考下。


//参照别人思路我的代码
public class Solution {
    ArrayList<String> result = new ArrayList<String>();
    public List<String> removeInvalidParentheses(String s) {
        find(s, 0, 0, new char[]{'(', ')'});
        return result;
    }
    
    public void find(String s, int lastI, int lastJ, char[] params) {
        int count = 0;
        for (int i=lastI; i<s.length(); i++) {
            if (s.charAt(i) == params[0])
                count++;
            else if (s.charAt(i) == params[1])
                count--;
                
            if (count < 0) {
                for (int j=lastJ; j<=i; j++) {
                    if (s.charAt(j) == params[1] && (j==lastJ || s.charAt(j-1)!=params[1]))      //避免重复的结果
                        find(s.substring(0, j)+s.substring(j+1, s.length()), i, j, params);
                }
                return;
            }
        }
        
        String re = new StringBuilder(s).reverse().toString();                                    //第二次处理
        if (params[0] == '(')
            find(re, 0, 0, new char[]{')', '('});
        else
            result.add(re);
    }
}
