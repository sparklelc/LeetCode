Mid
229 Majority Element II
Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times. 
The algorithm should run in linear time and in O(1) space.
找出出现1/3次以上的数字,要求时间复杂度O(n),空间复杂度O(1)


我的思路：
和找出现1/2次的数字思路差不多（那题是已经知道存在有个数字出现超1/2，而这里不知道是否存在），
如果数字出现过，count加一。否则去掉三个不同的数。
但关键是剩下的结果不一定是最终的结果，比如[1,2,3,4]返回4，但4不满足条件。
所以需要再从头遍历一次候选结果，统计它的出现次数看是否超过1/3.
称为Majority Vote Algorithm，分两步做，第一找候选结果，第二判断候选结果是否满足条件。



//我的代码：
public class Solution {
    public List<Integer> majorityElement(int[] nums) {
        ArrayList<Integer> result = new ArrayList<Integer>();
        Integer[] index = {null, null};
        int[] count = {0, 0};
        for (int i=0; i<nums.length; i++) {
            Integer item = new Integer(nums[i]);
            if (item.equals(index[0])) {
                count[0] ++;
            } else if (item.equals(index[1]) || count[1] == 0) {
                index[1] = item;
                count[1] ++;
            } else if (count[0] == 0) {
                count[0] ++;
                index[0] = item;
            } else {
                count[0] --;
                count[1] --;
            }
        }
        count[0] = 0;
        count[1] = 0;
        for (int i=0; i<nums.length; i++) {       //需要再遍历一次这里我一开始没想到
            Integer item = new Integer(nums[i]);
            if (item.equals(index[0]))
                count[0] ++;
            if (item.equals(index[1]))
                count[1] ++;
        }
        if (count[0] > nums.length/3.0)
            result.add(index[0]);
        if (count[1] > nums.length/3.0)
            result.add(index[1]);
        return result;
    }
}
