153 Mid:
Suppose a sorted array is rotated at some pivot unknown to you beforehand.
(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).
Find the minimum element.
You may assume no duplicate exists in the array.


思路：
我一开始直接遍历数组了，O(n), 也通过了
应该用二分查找，O(lgn)


我的二分查找代码：
public class Solution {
    public int findMin(int[] nums) {
        int low = 0;
        int high = nums.length - 1;
        while (low < high) {
            int mid = (low + high) / 2;
            if (mid == low) return Math.min(nums[mid], nums[high]);
            if (nums[mid] > nums[high])
                low = mid;
            else 
                high = mid;
        }
        return nums[low];
    }
}

********************************************************

154 Mid
在上面一题的基础上，可能出现重复的元素
如［3, 3, 3, 1, 3］和 [3, 1 ,3, 3, 3]

我的二分代码：
public class Solution {
    public int findMin(int[] nums) {
        int low = 0;
        int high = nums.length - 1;
        while (low < high) {
            int mid = (low + high)/2;
            if (mid == low)
                return Math.min(nums[mid], nums[high]);
            if (nums[mid] == nums[high])　　　　　　　　　　　　　　// 如果相等，只减少一个元素，而非二分
                high--;
            else if (nums[mid] > nums[high])
                low = mid;
            else
                high = mid;
        }
        return nums[low];
    }
}
